<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kide</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;500&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      overflow: hidden;
    }

    body {
      background: #000;
      color: #e8eef4;
      font-family: 'Inter', system-ui, sans-serif;
    }

    #shader-canvas {
      position: fixed;
      inset: 0;
      z-index: 0;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    /* Content overlay */
    #content {
      position: fixed;
      inset: 0;
      z-index: 10;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      pointer-events: none;
    }

    .slide {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      padding: 8vw;
      opacity: 0;
      transition: opacity 0.8s ease;
      pointer-events: none;
    }

    .slide.active {
      opacity: 1;
      pointer-events: auto;
    }

    .slide.center {
      align-items: center;
      text-align: center;
    }

    .slide.right {
      align-items: flex-end;
      text-align: right;
    }

    /* Content box - crystalline feel */
    .content-box {
      background: rgba(5, 8, 18, 0.75);
      padding: 4rem 5rem;
      backdrop-filter: blur(20px);
      max-width: 700px;
      border: 1px solid rgba(100, 150, 255, 0.15);
      clip-path: polygon(
        0% 8%, 3% 0%, 97% 0%, 100% 8%,
        100% 92%, 97% 100%, 3% 100%, 0% 92%
      );
    }

    .label {
      font-size: 0.7rem;
      letter-spacing: 0.25em;
      text-transform: uppercase;
      opacity: 0.5;
      margin-bottom: 1.5rem;
    }

    h1 {
      font-size: clamp(2.5rem, 8vw, 5rem);
      font-weight: 200;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      margin-bottom: 1rem;
    }

    h2 {
      font-size: clamp(1.8rem, 4vw, 2.8rem);
      font-weight: 300;
      line-height: 1.3;
      margin-bottom: 1.5rem;
    }

    p {
      font-size: 1.1rem;
      font-weight: 300;
      line-height: 1.8;
      opacity: 0.8;
    }

    .tagline {
      font-size: clamp(1rem, 2vw, 1.3rem);
      opacity: 0.7;
      letter-spacing: 0.05em;
    }

    .cta {
      display: inline-block;
      padding: 1rem 2.5rem;
      border: 1px solid rgba(100, 150, 255, 0.3);
      color: #e8eef4;
      text-decoration: none;
      font-size: 0.85rem;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      transition: all 0.3s ease;
      pointer-events: auto;
      margin-top: 1rem;
      clip-path: polygon(0% 20%, 5% 0%, 95% 0%, 100% 20%, 100% 80%, 95% 100%, 5% 100%, 0% 80%);
    }

    .cta:hover {
      background: rgba(100, 150, 255, 0.15);
      border-color: rgba(100, 150, 255, 0.6);
    }

    /* Navigation dots */
    #nav-dots {
      position: fixed;
      right: 3rem;
      top: 50%;
      transform: translateY(-50%);
      z-index: 20;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .nav-dot {
      width: 8px;
      height: 8px;
      background: rgba(100, 150, 255, 0.25);
      cursor: pointer;
      transition: all 0.3s ease;
      clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
    }

    .nav-dot.active {
      background: rgba(100, 150, 255, 0.9);
      transform: scale(1.5);
    }

    .nav-dot:hover {
      background: rgba(100, 150, 255, 0.5);
    }

    /* Scroll hint */
    #scroll-hint {
      position: fixed;
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.7rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      opacity: 0.4;
      z-index: 20;
      transition: opacity 0.5s ease;
    }
  </style>
</head>
<body>
  <div id="shader-canvas">
    <canvas id="glcanvas"></canvas>
  </div>

  <div id="content">
    <!-- Slide 0: Hero -->
    <div class="slide center active">
      <div class="content-box">
        <h1>Kide</h1>
        <p class="tagline">Structure forming slowly</p>
      </div>
    </div>

    <!-- Slide 1: Sellers -->
    <div class="slide">
      <div class="content-box">
        <div class="label">For Sellers</div>
        <h2>Clarity from complexity</h2>
        <p>When you're ready for your next chapter, we offer fair terms and a commitment to preserve what you've built. Your legacy crystallizes into something lasting.</p>
      </div>
    </div>

    <!-- Slide 2: Investors -->
    <div class="slide right">
      <div class="content-box">
        <div class="label">For Investors</div>
        <h2>Patience reveals structure</h2>
        <p>Curated opportunities in sustainable companies with strong fundamentals. For institutions and family offices seeking long-term value.</p>
      </div>
    </div>

    <!-- Slide 3: Operators -->
    <div class="slide">
      <div class="content-box">
        <div class="label">For Operators</div>
        <h2>Shape what's forming</h2>
        <p>Lead a Kide portfolio company. Real ownership, meaningful work, lasting impact.</p>
      </div>
    </div>

    <!-- Slide 4: Closing -->
    <div class="slide center">
      <div class="content-box">
        <h2>Let's talk</h2>
        <a href="mailto:hello@kide.fi" class="cta">Start a conversation</a>
      </div>
    </div>
  </div>

  <div id="nav-dots"></div>
  <div id="scroll-hint">Scroll</div>

  <script>
    // ============ WEBGL SHADER ============
    const canvas = document.getElementById('glcanvas');
    const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');

    if (!gl) {
      console.error('WebGL not supported');
    }

    // Vertex shader - simple fullscreen quad
    const vertexShaderSource = `#version 300 es
      in vec4 a_position;
      void main() {
        gl_Position = a_position;
      }
    `;

    // Fragment shader - Alcatraz fractalscape (simplified for single pass)
    const fragmentShaderSource = `#version 300 es
      precision highp float;

      uniform vec2 iResolution;
      uniform float iTime;
      uniform float iCameraZ;

      out vec4 fragColor;

      // 3D noise function (IQ)
      float noise(vec3 p) {
        vec3 ip = floor(p);
        p -= ip;
        vec3 s = vec3(7.0, 157.0, 113.0);
        vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);
        p = p * p * (3.0 - 2.0 * p);
        h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), p.x);
        h.xy = mix(h.xz, h.yw, p.y);
        return mix(h.x, h.y, p.z);
      }

      // KIFS fractal
      int meep = 0;
      float kifs(vec3 p) {
        vec3 offs = vec3(1.0, 0.75, 0.5);
        vec2 a = sin(vec2(0.0, 1.57) + 1.57 / 2.0);
        vec2 b = sin(vec2(0.0, 1.57) + 1.57 / 4.0);
        float s = 5.0;
        float d = 1e5;
        p = abs(fract(p * 0.5) * 2.0 - 1.0);
        float amp = 1.0 / s;

        for(int i = 0; i < 5; i++) {
          p.xy = mat2(a.y, -a.x, a) * p.xy;
          p.yz = mat2(b.y, -b.x, b) * p.yz;
          p = abs(p);
          if(p.x < p.y) p.xy = p.yx;
          if(p.x < p.z) p.xz = p.zx;
          if(p.y < p.z) p.yz = p.zy;
          p = p * s + offs * (1.0 - s);
          p.z -= step(p.z, offs.z * (1.0 - s) * 0.5) * offs.z * (1.0 - s);
          p = abs(p);
          d = min(d, max(max(p.x, p.y), p.z) * amp);
          amp /= s;
          if(i == 1 && p.x > (9.0 + 1.0 * sin(0.209 * iTime + 1.0))) meep = 1;
        }
        return d - 0.29;
      }

      float map(vec3 p) {
        float f = -0.05 - kifs(0.4 * p);
        if(meep == 0) f += 0.002 * noise(p * 70.0);
        return f;
      }

      vec3 calcNormal(vec3 pos) {
        float eps = 0.0001;
        float d = map(pos);
        return normalize(vec3(
          map(pos + vec3(eps, 0, 0)) - d,
          map(pos + vec3(0, eps, 0)) - d,
          map(pos + vec3(0, 0, eps)) - d
        ));
      }

      float castRay(vec3 ro, vec3 rd) {
        float function_sign = (map(ro) < 0.0) ? -1.0 : 1.0;
        float precis = 0.0001;
        float h = precis * 2.0;
        float t = 0.0;
        for(int i = 0; i < 120; i++) {
          if(abs(h) < precis || t > 12.0) break;
          h = function_sign * map(ro + rd * t);
          t += h;
        }
        return t;
      }

      float refr(vec3 pos, vec3 lig, vec3 dir, vec3 nor, float angle, out float t2, out vec3 nor2) {
        float h = 0.0;
        t2 = 2.0;
        vec3 dir2 = refract(dir, nor, angle);
        for(int i = 0; i < 50; i++) {
          if(abs(h) > 3.0) break;
          h = map(pos + dir2 * t2);
          t2 -= h;
        }
        nor2 = calcNormal(pos + dir2 * t2);
        return(0.5 * clamp(dot(-lig, nor2), 0.0, 1.0) + pow(max(dot(reflect(dir2, nor2), lig), 0.0), 8.0));
      }

      float softshadow(vec3 ro, vec3 rd) {
        float sh = 1.0;
        float t = 0.02;
        float h = 0.0;
        for(int i = 0; i < 22; i++) {
          if(t > 20.0) continue;
          h = map(ro + rd * t);
          sh = min(sh, 4.0 * h / t);
          t += h;
        }
        return sh;
      }

      void main() {
        float bounce = abs(fract(0.05 * iTime) - 0.5) * 20.0;
        meep = 0;
        vec2 uv = gl_FragCoord.xy / iResolution.xy;
        vec2 p = uv * 2.0 - 1.0;

        float wobble = (fract(0.1 * (iTime - 1.0)) >= 0.9) ? fract(-iTime) * 0.1 * sin(30.0 * iTime) : 0.0;

        vec3 dir = normalize(vec3(2.0 * gl_FragCoord.xy - iResolution.xy, iResolution.y));
        vec3 org = vec3(0.0, 2.0 * wobble, -3.0);

        vec2 m = sin(vec2(0.0, 1.57) + iTime / 8.0);
        dir.xy = mat2(m.y, -m.x, m) * dir.xy;
        dir.xz = mat2(m.y, -m.x, m) * dir.xz;
        org = vec3(0.0, 2.0 + wobble, 0.0 + 8.0 * sin(bounce / 3.0) + iCameraZ);

        vec3 color = vec3(0.0);
        vec3 color2 = vec3(0.0);
        float t = castRay(org, dir);
        vec3 pos = org + dir * t;
        vec3 nor = calcNormal(pos);

        vec3 lig = normalize(-pos);
        float depth = clamp((1.0 - 0.09 * t), 0.0, 1.0);
        vec3 pos2, nor2 = vec3(0.0);

        if(t < 12.0) {
          color2 = vec3(max(dot(lig, nor), 0.0) + pow(max(dot(reflect(dir, nor), lig), 0.0), 16.0));
          color2 *= clamp(softshadow(pos, lig), 0.0, 1.0);

          if(meep == 1) {
            float t2;
            color2.r += refr(pos, lig, dir, nor, 0.91, t2, nor2) * depth;
            color2.g += refr(pos, lig, dir, nor, 0.90, t2, nor2) * depth;
            color2.b += refr(pos, lig, dir, nor, 0.89, t2, nor2) * depth;
            color2 -= clamp(0.1 * t2, 0.0, 1.0);
          }
        }

        float tmp = 0.0;
        float T = 1.0;
        float intensity = 0.1 * -sin(0.209 * iTime + 1.0) + 0.05;

        for(int i = 0; i < 128; i++) {
          float density = 0.0;
          float nebula = noise(org + bounce);
          density = (meep == 1) ? intensity - map(org + 0.5 * nor2) * nebula : 0.7 * intensity - map(org) * nebula;
          if(density > 0.0) {
            tmp = density / 128.0;
            T *= 1.0 - tmp * 100.0;
            if(T <= 0.0) break;
          }
          org += dir * 0.078;
        }

        vec3 basecol = vec3(1.0/16.0, 0.25, 1.0);
        T = clamp(T, 0.0, 1.5);
        color += basecol * exp(4.0 * (0.5 - T) - 0.8);
        color2 *= depth;
        color2 += (1.0 - depth) * noise(6.0 * dir + 0.3 * iTime) * 0.1;

        fragColor = vec4(vec3(1.0 * color + 0.8 * color2) * 1.3, 1.0);
      }
    `;

    // Compile shader
    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('Shader compile error:', gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    // Create program
    function createProgram(gl, vertexShader, fragmentShader) {
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Program link error:', gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
        return null;
      }
      return program;
    }

    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
    const program = createProgram(gl, vertexShader, fragmentShader);

    // Fullscreen quad
    const positions = new Float32Array([
      -1, -1,
       1, -1,
      -1,  1,
      -1,  1,
       1, -1,
       1,  1,
    ]);

    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

    const positionLocation = gl.getAttribLocation(program, 'a_position');
    const resolutionLocation = gl.getUniformLocation(program, 'iResolution');
    const timeLocation = gl.getUniformLocation(program, 'iTime');
    const cameraZLocation = gl.getUniformLocation(program, 'iCameraZ');

    let startTime = Date.now();
    let currentCameraZ = 0;
    let targetCameraZ = 0;

    function resize() {
      const dpr = window.devicePixelRatio || 1;
      canvas.width = window.innerWidth * dpr;
      canvas.height = window.innerHeight * dpr;
      gl.viewport(0, 0, canvas.width, canvas.height);
    }

    function render() {
      const time = (Date.now() - startTime) / 1000;

      // Smooth camera movement
      currentCameraZ += (targetCameraZ - currentCameraZ) * 0.05;

      gl.useProgram(program);
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.enableVertexAttribArray(positionLocation);
      gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

      gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
      gl.uniform1f(timeLocation, time);
      gl.uniform1f(cameraZLocation, currentCameraZ);

      gl.drawArrays(gl.TRIANGLES, 0, 6);
      requestAnimationFrame(render);
    }

    window.addEventListener('resize', resize);
    resize();
    render();

    // ============ SLIDE NAVIGATION ============
    const slides = document.querySelectorAll('.slide');
    const navDotsContainer = document.getElementById('nav-dots');
    const scrollHint = document.getElementById('scroll-hint');
    const totalSlides = 5;
    let currentSlide = 0;
    let isAnimating = false;

    // Camera Z positions for each slide
    const cameraStates = [0, 5, 10, 15, 20];

    // Create nav dots
    for (let i = 0; i < totalSlides; i++) {
      const dot = document.createElement('div');
      dot.className = 'nav-dot' + (i === 0 ? ' active' : '');
      dot.addEventListener('click', () => goToSlide(i));
      navDotsContainer.appendChild(dot);
    }
    const navDots = document.querySelectorAll('.nav-dot');

    function goToSlide(index) {
      if (isAnimating || index === currentSlide || index < 0 || index >= totalSlides) return;
      isAnimating = true;

      slides[currentSlide].classList.remove('active');
      slides[index].classList.add('active');

      navDots[currentSlide].classList.remove('active');
      navDots[index].classList.add('active');

      // Move camera through the fractal
      targetCameraZ = cameraStates[index];

      setTimeout(() => {
        currentSlide = index;
        isAnimating = false;
      }, 800);

      scrollHint.style.opacity = '0';
    }

    // Scroll handling
    let scrollAccumulator = 0;
    const scrollThreshold = 50;

    window.addEventListener('wheel', (e) => {
      e.preventDefault();
      scrollAccumulator += e.deltaY;

      if (Math.abs(scrollAccumulator) > scrollThreshold) {
        if (scrollAccumulator > 0) {
          goToSlide(currentSlide + 1);
        } else {
          goToSlide(currentSlide - 1);
        }
        scrollAccumulator = 0;
      }
    }, { passive: false });

    // Keyboard navigation
    window.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowDown' || e.key === 'ArrowRight') {
        goToSlide(currentSlide + 1);
      } else if (e.key === 'ArrowUp' || e.key === 'ArrowLeft') {
        goToSlide(currentSlide - 1);
      }
    });

    // Touch handling
    let touchStartY = 0;
    window.addEventListener('touchstart', (e) => {
      touchStartY = e.touches[0].clientY;
    });

    window.addEventListener('touchend', (e) => {
      const touchEndY = e.changedTouches[0].clientY;
      const diff = touchStartY - touchEndY;

      if (Math.abs(diff) > 50) {
        if (diff > 0) {
          goToSlide(currentSlide + 1);
        } else {
          goToSlide(currentSlide - 1);
        }
      }
    });
  </script>
</body>
</html>
